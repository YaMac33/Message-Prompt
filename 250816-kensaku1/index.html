<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- ページタイトル：記事内容を端的かつ魅力的に表現 -->
  <title>25.8.16 静的サイト向け：Lunr.js と Algolia で作る検索実装ガイド（Jekyll不要）</title>
  <!-- サイト全体のスタイル（指定どおり1回だけ読み込み） -->
  <link rel="stylesheet" href="/ai-comparison-test-site/style.css" />
  <!-- 最低限のインラインCSS（20行以内）: ヘッダー重なり回避、画像レスポンシブ、フェード/ボタン -->
  <style>
    /* コンテンツが固定ヘッダーに隠れないように余白を確保（ヘッダー挿入後にJSで調整） */
    .content { padding: 1.5rem; padding-top: var(--header-height,72px); max-width:900px; margin:0 auto; }
    figure img { max-width:100%; height:auto; display:block; }
    .fade-in { opacity:0; transform: translateY(10px); transition: opacity .6s ease, transform .6s ease; }
    .fade-in.visible { opacity:1; transform: translateY(0); }
    #to-top { position:fixed; right:1rem; bottom:1.5rem; display:inline-block; padding:.6rem .8rem; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,.15); background:#fff; cursor:pointer; opacity:0; pointer-events:none; transition:opacity .3s ease; }
    #to-top.show { opacity:1; pointer-events:auto; }
  </style>
</head>
<body>
  <!-- ヘッダーを動的に読み込むためのマウントポイント -->
  <div id="header-mount" aria-hidden="true"></div>
  <main class="content" id="main-content">
    <!-- 主見出し（絵文字を控えめに） -->
    <h1>静的サイトで導入するサイト内検索：Lunr.js（自力）とAlgolia（外部）の2パターン解説 🔎</h1>
```
<!-- 目次はJSで自動生成（h2/h3を抽出） -->
<nav id="table-of-contents" aria-label="目次"></nav>
<!-- 記事本文 -->
<article id="article-body">
  <!-- 方法A（Lunr.js） -->
  <section class="fade-in fade-in-target">
    <h2>方法A：Lunr.js を使う（自力で完結させる方法） 🧰</h2>
    <p>外部サービスに頼らず、無料でサイト内検索を実装する方法です。サイトの全ページの情報をまとめたJSONファイルを手動（またはスクリプトで）作成し、それを使って検索します。</p>
    <h3>ステップ1：検索データ <code>search-index.json</code> を作成する</h3>
    <p>まず、サイト内の検索対象にしたいページの情報をまとめたJSONファイルを作成します。作業は手動でもスクリプトでも構いませんが、このファイルが検索の核になります。</p>
    <figure>
      <!-- 画像は本文に無いので例示は省略。altは必須。 -->
      <figcaption>search-index.json のイメージ（例）</figcaption>
    </figure>
    <pre><code aria-label="search-index.jsonの例">[
```
{
"id": 0,
"url": "/about.html",
"title": "このサイトについて",
"content": "このサイトの運営方針や目的について説明しています。..."
},
{
"id": 1,
"url": "/products/item01.html",
"title": "製品Aの紹介",
"content": "主力製品である製品Aの機能や特徴を詳しく解説します。..."
}
]</code></pre>

```
    <p><strong>ポイント：</strong> <em>id</em>は0から開始する連番、<em>url</em>はページパス、<em>title</em>と<em>content</em>は検索にヒットさせたい情報を要約して入れます。</p>

    <h3>ステップ2：HTMLに検索フォームと結果エリアを設置する</h3>
    <p>検索フォームの最低限の例：</p>
    <div>
      <label for="search-input">サイト内を検索（2文字以上）🔎</label>
      <input id="search-input" type="text" placeholder="サイト内を検索..." aria-label="サイト内検索" />
      <ul id="results-container" aria-live="polite"></ul>
    </div>

    <h3>ステップ3：JavaScriptを記述する（Lunr.jsを使用）</h3>
    <p>以下のスクリプトを追加します。まずは Lunr.js 本体を読み込む必要があります（例：CDN）。</p>
    <p>参考 CDN（クリックして別タブで開く）：<br />
      <a href="https://unpkg.com/lunr/lunr.min.js">https://unpkg.com/lunr/lunr.min.js</a>
    </p>

    <blockquote>
      <p>以下は記事中のサンプルコードです（抜粋）。実際は <code>&lt;script src="...">&lt;/script></code> をページに含めてください。</p>
    </blockquote>

    <pre><code aria-label="lunrサンプル"> &lt;script src="https://unpkg.com/lunr/lunr.min.js">&lt;/script>
```

\<script>
(async function() {
const searchInput = document.getElementById('search-input');
const resultsContainer = document.getElementById('results-container');
const response = await fetch('/search-index.json');
const documents = await response.json();
const idx = lunr(function () {
this.ref('id');
this.field('title');
this.field('content');
documents.forEach(function (doc) { this.add(doc); }, this);
});
searchInput.addEventListener('input', function (event) {
const query = event.target.value;
resultsContainer.innerHTML = '';
if (query.length < 2) return;
const results = idx.search(query);
if (results.length > 0) {
results.forEach(function (result) {
const item = documents.find(doc => doc.id == result.ref);
const li = document.createElement('li');
li.innerHTML = '\<a href="' + item.url + '">' + item.title + '\</a>';
resultsContainer.appendChild(li);
});
} else {
const noResult = document.createElement('li');
noResult.textContent = '該当するページは見つかりませんでした。';
resultsContainer.appendChild(noResult);
}
});
})();
\</script></code></pre>

```
    <p>この方法はページ数が数十〜百ページ程度であれば十分に実用的です。</p>
  </section>

  <!-- 方法B（簡潔に） -->
  <section class="fade-in fade-in-target">
    <h2>方法B：Algolia を使う（高機能な外部サービス） ☁️</h2>
    <p>高性能な外部サービスを利用するパターンです。サーバー側でインデックスを作成したり、フロントエンド向けAPIキーの管理、ランキングやファセット検索など高度な機能が使えます。規模が大きいサイトや検索体験を重視する場合に有利です。</p>

    <h3>Algolia のメリット</h3>
    <ul>
      <li>高速でスケーラブルな検索</li>
      <li>ランキング/ファセット/レコメンドなどの高度機能</li>
      <li>ホスティングやセキュリティ面の利便性</li>
    </ul>

    <h3>Algolia の注意点</h3>
    <ul>
      <li>利用料金が発生する（無料枠はあるが制限あり）</li>
      <li>外部サービスに依存する設計になる</li>
    </ul>
  </section>

  <!-- まとめ -->
  <section class="fade-in fade-in-target">
    <h2>まとめ ✅</h2>
    <p>小〜中規模の静的サイトでコストを抑え自前で完結させたいなら <strong>Lunr.js</strong> が現実的です。一方、検索体験・性能・運用性を重視する場合は <strong>Algolia</strong> を検討しましょう。</p>
    <blockquote>
      <p>参考：記事内の Lunr.js CDN のURLは <a href="https://unpkg.com/lunr/lunr.min.js">https://unpkg.com/lunr/lunr.min.js</a> です。</p>
    </blockquote>
  </section>
</article>
```

  </main>
  <!-- トップへ戻るボタン（アクセシビリティのためaria-labelを付与） -->
<button id="to-top" aria-label="トップへ戻る">↑ トップへ戻る</button>
  <!-- JavaScript：ヘッダー読み込み、目次生成、IntersectionObserver、トップボタン等（コメント多数） -->
  <script>
    // ============================
    // ヘッダーの動的読み込み
    // - fetch + DOMParser を使い、header.html の <body> 要素内（または全体）の中身だけを挿入する
    // - header.html は同ディレクトリに配置されていることを想定
    // - 読み込み後に実際のヘッダー高さを --header-height CSS変数に設定して重なりを防止
    // ============================
    (async function loadHeader() {
      try {
        const mount = document.getElementById('header-mount');
        const res = await fetch('/ai-comparison-test-site/header.html', {cache: 'no-cache'});
        if (!res.ok) throw new Error('ヘッダー取得失敗');
        const text = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');

        // 取得したドキュメントの <body> または <div class="site-header"> 等を探して挿入
        // 優先的に body の中身を使用
        let contentNode = doc.body;
        // If header is wrapped in specific selector, try to pick it (graceful fallback)
        const specific = doc.querySelector('.site-header') || doc.querySelector('.header-container');
        if (specific) contentNode = specific;

        // Insert the children into mount
        while (mount.firstChild) mount.removeChild(mount.firstChild);
        Array.from(contentNode.childNodes).forEach(node => mount.appendChild(node.cloneNode(true)));

        // After insertion, compute header height and set CSS variable to avoid overlap
        requestAnimationFrame(() => {
          const headerEl = mount.firstElementChild || mount;
          const rect = headerEl.getBoundingClientRect();
          const height = Math.ceil(rect.height) + 8; // 少し余裕を入れる
          document.documentElement.style.setProperty('--header-height', height + 'px');
          mount.setAttribute('aria-hidden', 'false');
        });
      } catch (e) {
        console.error('ヘッダー読み込みでエラー:', e);
      }
    })();

    // ============================
    // 目次（TOC）の自動生成
    // - ページ内の h2/h3 を抽出し、h1 の直後に生成
    // - 各見出しにユニークIDを付与（スラッグ化 + 競合回避）
    // - アクセシビリティ：aria-label を付与
    // ============================
    (function buildTOC() {
      // helper: スラッグ化
      function slugify(text) {
        return text.toString().toLowerCase()
          .trim()
          .replace(/[^\w\u3040-\u30ff\u4e00-\u9fff\- ]+/g, '') // 日本語と英数字、スペースのみ残す
          .replace(/\s+/g, '-')
          .replace(/\-+/g, '-');
      }

      const content = document.getElementById('article-body');
      if (!content) return;

      const headings = content.querySelectorAll('h2, h3');
      if (headings.length === 0) return;

      const toc = document.getElementById('table-of-contents');
      const ul = document.createElement('ul');
      ul.className = 'toc-list';
      ul.setAttribute('aria-label', '目次リスト');

      const used = new Map(); // id 重複回避

      headings.forEach(h => {
        // create unique id if missing
        if (!h.id) {
          let base = slugify(h.textContent || h.innerText || 'heading');
          let id = base;
          let i = 1;
          while (used.has(id) || document.getElementById(id)) {
            id = base + '-' + i++;
          }
          used.set(id, true);
          h.id = id;
        }
        // list item
        const li = document.createElement('li');
        li.className = 'toc-item toc-' + h.tagName.toLowerCase();
        const a = document.createElement('a');
        a.href = '#' + h.id;
        a.textContent = (h.tagName.toLowerCase() === 'h2' ? '■ ' : '– ') + h.textContent;
        a.setAttribute('aria-label', '目次：' + h.textContent);
        li.appendChild(a);
        ul.appendChild(li);
      });

      // Insert TOC after the main h1
      const h1 = document.querySelector('h1');
      if (h1 && h1.parentNode) {
        const wrapper = document.createElement('div');
        wrapper.className = 'toc-wrapper fade-in fade-in-target';
        const title = document.createElement('p');
        title.className = 'toc-title';
        title.textContent = '目次（クリックで該当箇所へ移動）';
        wrapper.appendChild(title);
        wrapper.appendChild(ul);
        h1.insertAdjacentElement('afterend', wrapper);
      } else {
        toc.appendChild(ul);
      }
    })();

    // ============================
    // IntersectionObserver を使ったフェードイン（スクロールアニメーション）
    // - .fade-in-target を監視して .visible を付与
    // ============================
    (function initScrollAnimations() {
      const targets = document.querySelectorAll('.fade-in-target');
      if (!targets.length) return;
      const io = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            // 1回だけアニメーションするなら unobserve する
            io.unobserve(entry.target);
          }
        });
      }, { threshold: 0.12 });
      targets.forEach(t => io.observe(t));
    })();

    // ============================
    // 「トップへ戻る」ボタンの表示 & スムーススクロール
    // - 一画面分（window.innerHeight）スクロールしたら表示
    // - クリック時にスムーススクロール
    // ============================
    (function initToTopButton() {
      const btn = document.getElementById('to-top');
      if (!btn) return;
      function check() {
        if (window.scrollY > window.innerHeight) {
          btn.classList.add('show');
        } else {
          btn.classList.remove('show');
        }
      }
      window.addEventListener('scroll', check, { passive: true });
      window.addEventListener('resize', check);
      // 初回チェック
      check();

      btn.addEventListener('click', function () {
        window.scrollTo({ top: 0, behavior: 'smooth' });
        btn.blur();
      });
      // キーボード操作でもアクセスできるように Enter/Space をハンドル
      btn.addEventListener('keydown', function (e) {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          btn.click();
        }
      });
    })();

    // ============================
    // 補助：hashリンククリック時に余白分だけスクロール位置を補正（固定ヘッダー対応）
    // - ページ内リンクがヘッダーに隠れないよう、クリック時/ロード時に調整
    // ============================
    (function adjustHashOffset() {
      function offsetScroll() {
        if (location.hash) {
          const el = document.getElementById(location.hash.slice(1));
          if (el) {
            const headerH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--header-height')) || 72;
            const rect = el.getBoundingClientRect();
            const absoluteTop = window.scrollY + rect.top - headerH - 12; // 少し余裕
            window.scrollTo({ top: absoluteTop, behavior: 'smooth' });
          }
        }
      }
      // hash がある場合ロード後に補正
      window.addEventListener('load', function(){ setTimeout(offsetScroll, 80); });
      // ページ内リンククリック時にも補正
      document.addEventListener('click', function(e){
        const a = e.target.closest('a[href^="#"]');
        if (a) {
          // デフォルト後に補正
          setTimeout(offsetScroll, 10);
        }
      });
    })();
  </script>
</body>
</html>
